<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>My Website</title>
  <link href="resources/styles/style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <main>
    <section>
      <h1>Home</h1>
      <button id="theme">Toggle</button>
    </section>
    <section>
      <h1>About</h1>
    </section>
    <section>
      <canvas width="512" height="512"></canvas>
      <script type="module">
        const canvas = document.querySelector("canvas");

        // Your WebGPU code will begin here!
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0.4, a: 1 }, // New line
            storeOp: "store",
          }]
        });

        pass.setPipeline(cellPipeline);
        pass.setVertexBuffer(0, vertexBuffer);
        pass.draw(vertices.length / 2); // 6 vertices

        pass.end();
        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);
        // Finish the command buffer and immediately submit it.
        device.queue.submit([encoder.finish()]);

        const vertices = new Float32Array([
          //   X,    Y,
          -0.8, -0.8, // Triangle 1 (Blue)
          0.8, -0.8,
          0.8, 0.8,

          -0.8, -0.8, // Triangle 2 (Red)
          0.8, 0.8,
          -0.8, 0.8,
        ]);

        const vertexBuffer = device.createBuffer({
          label: "Cell vertices",
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);

        const vertexBufferLayout = {
          arrayStride: 8,
          attributes: [{
            format: "float32x2",
            offset: 0,
            shaderLocation: 0, // Position, see vertex shader
          }],
        };

        const cellShaderModule = device.createShaderModule({
          label: "Cell shader",
          code: `
            @vertex
            fn vertexMain(@location(0) pos: vec2f) ->
              @builtin(position) vec4f {
              return vec4f(pos, 0, 1);
            }

            @fragment
            fn fragmentMain() -> @location(0) vec4f {
                return vec4f(1, 0, 0, 1); // (Red, Green, Blue, Alpha)
            }
          `
        });

        const cellPipeline = device.createRenderPipeline({
          label: "Cell pipeline",
          layout: "auto",
          vertex: {
            module: cellShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout]
          },
          fragment: {
            module: cellShaderModule,
            entryPoint: "fragmentMain",
            targets: [{
              format: canvasFormat
            }]
          }
        });







      </script>
    </section>
  </main>

</body>

<script src="https://unpkg.com/axios/dist/axios.min.js" defer></script>
<script src="resources/js/main.js" defer></script>

</html>